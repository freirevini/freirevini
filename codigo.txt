# -*- coding: utf-8 -*-
"""
MKCompliance – 3 tentativas, validação, compactação
Usa o perfil real do Edge (sem InPrivate)

Atualizado: 17-06-2025
"""

import os, sys, time, shutil, zipfile
from datetime import datetime
from pathlib import Path

import pandas as pd
from playwright.sync_api import sync_playwright, expect

# ------------------------------------------------------------------
# Funções de log (ASCII seguro)
# ------------------------------------------------------------------
def klog(msg: str):
    sys.stdout.write(msg + "\n"); sys.stdout.flush()

def kerr(msg: str):
    sys.stderr.write("ERROR: " + msg + "\n"); sys.stderr.flush()

# ------------------------------------------------------------------
# Caminhos dinâmicos
# ------------------------------------------------------------------
USER_DOCS = Path(os.environ["USERPROFILE"]) / "Documents"
RUN_ROOT  = USER_DOCS / "mk"           # C:\Users\<usr>\Documents\mk
RUN_ROOT.mkdir(exist_ok=True)

# Pasta do perfil Edge padrão (“Default”) do usuário logado
EDGE_PROFILE = (
    Path(os.environ["LOCALAPPDATA"])
    / "Microsoft" / "Edge" / "User Data" / "Default"
)

# ------------------------------------------------------------------
# URLs de destino
# ------------------------------------------------------------------
LOGIN_INIT_URL = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/"
    "protocol/openid-connect/auth?response_type=code&client_id=alfresco"
    "&redirect_uri=https://bv.mkcompliance.com.br/mk/compliance.html"
)
ADMIN_URL  = "https://bv.mkcompliance.com.br/mk/admin.html#/cfghome"
LOGIN_BASE = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/protocol/openid-connect/auth"
)

TIMEOUT_MS = 90_000
MIN_COLS   = [
    "login", "Nome", "Sobrenome", "E-mail",
    "Telefone", "Departamento", "Área",
]

# ------------------------------------------------------------------
# Uma tentativa de download
# ------------------------------------------------------------------
def do_attempt(pw, attempt_dir: Path, n: int) -> pd.DataFrame:
    file_name = "pontosfocaisMK.xlsx"
    xlsx_path = attempt_dir / file_name
    zip_path  = attempt_dir / (file_name + ".zip")

    ctx = page = None
    df  = pd.DataFrame()

    klog(f"Attempt {n} - {attempt_dir}")

    try:
        ctx = pw.chromium.launch_persistent_context(
            user_data_dir=str(EDGE_PROFILE),    # perfil real
            channel="msedge",
            headless=False,
            timeout=TIMEOUT_MS,
            args=["--profile-directory=Default"]  # garante o perfil certo
            # (NÃO há --inprivate!)
        )
        page = ctx.new_page()

        # 1) Login (SSO se necessário)
        page.goto(LOGIN_INIT_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        if page.url.startswith(LOGIN_BASE):
            klog("SSO → clicando Microsoft")
            expect(page.get_by_role("link", name="Microsoft")).to_be_visible(timeout=TIMEOUT_MS)
            page.get_by_role("link", name="Microsoft").click()
            page.wait_for_url("https://bv.mkcompliance.com.br/mk/compliance.html**", timeout=TIMEOUT_MS)

        # 2) Navegação interna
        page.goto(ADMIN_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        expect(page.get_by_text("Gestão de Usuários Permite")).to_be_visible(timeout=TIMEOUT_MS)
        page.get_by_text("Gestão de Usuários Permite").click()

        # espera coluna “Área”
        klog("Esperando cabecalho 'Área'")
        expect(page.locator("th", has_text="Área")).to_be_visible(timeout=TIMEOUT_MS)
        page.wait_for_timeout(500)

        # 3) Download Excel
        with page.expect_download(timeout=TIMEOUT_MS) as dl_info:
            page.get_by_role("button", name="Excel").click()
        dl = dl_info.value
        dl.save_as(xlsx_path)
        klog(f"Salvo em {xlsx_path}")

        # aguarda tamanho estabilizar
        last = -1
        while True:
            size_now = os.path.getsize(xlsx_path)
            if size_now == last: break
            last = size_now; time.sleep(0.4)

        # 4) Ler e logar colunas
        df = pd.read_excel(xlsx_path, header=1, dtype=str)
        klog(f"Colunas ({len(df.columns)}): {list(df.columns)}")

        # 5) Validação
        if not all(c in df.columns for c in MIN_COLS):
            kerr("Colunas mínimas faltando")
            df = pd.DataFrame()
        else:
            klog("Colunas OK")

        # 6) Compacta e remove .xlsx
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
            zf.write(xlsx_path, arcname=file_name)
        os.remove(xlsx_path)
        klog("Compactado e .xlsx removido")

    except Exception as e:
        kerr(f"Falha attempt {n}: {e}")
        df = pd.DataFrame()
    finally:
        if ctx: ctx.close()

    return df

# ------------------------------------------------------------------
# Pipeline (até 3 tentativas)
# ------------------------------------------------------------------
def run_pipeline() -> pd.DataFrame:
    final_df = pd.DataFrame()

    with sync_playwright() as pw:
        for n in range(1, 4):
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            attempt_dir = RUN_ROOT / f"{ts}_try{n}"
            attempt_dir.mkdir(parents=True, exist_ok=True)

            df = do_attempt(pw, attempt_dir, n)

            # limpa subpasta
            shutil.rmtree(attempt_dir, ignore_errors=True)

            if not df.empty:
                klog(f"Concluído na tentativa {n}")
                final_df = df
                break

            klog(f"Tentativa {n} falhou, aguardando 5 s\n")
            time.sleep(5)

    # remove mk se ficar vazia
    try:
        if not any(RUN_ROOT.iterdir()):
            RUN_ROOT.rmdir()
    except Exception:
        pass

    if final_df.empty:
        kerr("Todas as 3 tentativas falharam")

    return final_df

# ------------------------------------------------------------------
# Execução (KNIME)
# ------------------------------------------------------------------
output_table = run_pipeline()
