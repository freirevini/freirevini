# -*- coding: utf-8 -*-
"""
MKCompliance – Download com tentativas, validacao e compactacao
Atualizado: 17-06-2025
"""

import os, sys, time, shutil, zipfile
from datetime import datetime
from pathlib import Path

import pandas as pd
from playwright.sync_api import sync_playwright, expect

# ------------------------------------------------------------------
# Funcoes de log (ASCII only)
# ------------------------------------------------------------------
def klog(msg: str):
    sys.stdout.write(msg + "\n")
    sys.stdout.flush()

def kerr(msg: str):
    sys.stderr.write("ERROR: " + msg + "\n")
    sys.stderr.flush()

# ------------------------------------------------------------------
# Pastas e URLs
# ------------------------------------------------------------------
PROFILE_DIR = Path(
    r"N:/DCGV/Compliance/Compliance RO Varejo/Analytics/Projetos/AgendaNormativa/edge_profile/edge_profile"
).resolve()

RUN_ROOT = Path(r"C:\Temp\mk_runs").resolve()
RUN_ROOT.mkdir(parents=True, exist_ok=True)

LOGIN_INIT_URL = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/"
    "protocol/openid-connect/auth?response_type=code&client_id=alfresco"
    "&redirect_uri=https://bv.mkcompliance.com.br/mk/compliance.html"
)
ADMIN_URL = "https://bv.mkcompliance.com.br/mk/admin.html#/cfghome"
LOGIN_BASE = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/protocol/openid-connect/auth"
)

TIMEOUT_MS = 90_000
MIN_COLS = [
    "login", "Nome", "Sobrenome", "E-mail",
    "Telefone", "Departamento", "Área",
]

# ------------------------------------------------------------------
# Uma tentativa de download / leitura
# ------------------------------------------------------------------
def do_attempt(play, attempt_dir: Path, attempt_n: int) -> pd.DataFrame:
    file_name = "pontosfocaisMK.xlsx"
    xlsx_path = attempt_dir / file_name
    zip_path = attempt_dir / (file_name + ".zip")

    ctx = page = None
    df = pd.DataFrame()

    klog("Attempt %d - directory %s" % (attempt_n, attempt_dir.name))

    try:
        ctx = play.chromium.launch_persistent_context(
            user_data_dir=PROFILE_DIR,
            channel="msedge",
            headless=False,
            timeout=TIMEOUT_MS,
        )
        page = ctx.new_page()

        # 1) Login se necessario
        page.goto(LOGIN_INIT_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        if page.url.startswith(LOGIN_BASE):
            klog("SSO - clicando em Microsoft")
            expect(page.get_by_role("link", name="Microsoft")).to_be_visible(timeout=TIMEOUT_MS)
            page.get_by_role("link", name="Microsoft").click()
            page.wait_for_url("https://bv.mkcompliance.com.br/mk/compliance.html**", timeout=TIMEOUT_MS)

        # 2) Navega direto para admin
        page.goto(ADMIN_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        expect(page.get_by_text("Gestão de Usuários Permite")).to_be_visible(timeout=TIMEOUT_MS)
        page.get_by_text("Gestão de Usuários Permite").click()

        # 3) Espera a grade carregar (cabecalho 'Área')
        klog("Esperando cabecalho 'Área' aparecer")
        expect(page.locator("th", has_text="Área")).to_be_visible(timeout=TIMEOUT_MS)
        page.wait_for_timeout(500)

        # 4) Download
        with page.expect_download(timeout=TIMEOUT_MS) as dl_info:
            page.get_by_role("button", name="Excel").click()
        dl = dl_info.value
        dl.save_as(xlsx_path)
        klog("Arquivo salvo em %s" % xlsx_path)

        # aguarda estabilizar
        last = -1
        while True:
            sz = os.path.getsize(xlsx_path)
            time.sleep(0.4)
            if sz == last:
                break
            last = sz

        # 5) Leitura
        df = pd.read_excel(xlsx_path, header=1, dtype=str)
        klog("Colunas importadas: %s" % list(df.columns))

        # 6) Validacao
        if not all(c in df.columns for c in MIN_COLS):
            kerr("Colunas minimas faltando")
            df = pd.DataFrame()
        else:
            klog("Colunas minimas OK")

        # 7) Compacta e remove xlsx
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
            zf.write(xlsx_path, arcname=file_name)
        os.remove(xlsx_path)
        klog("Compactado em %s e .xlsx removido" % zip_path.name)

    except Exception as e:
        kerr("Falha tentativa %d: %s" % (attempt_n, e))
        df = pd.DataFrame()
    finally:
        if ctx:
            ctx.close()

    return df

# ------------------------------------------------------------------
# Pipeline com ate 3 tentativas
# ------------------------------------------------------------------
def run_pipeline() -> pd.DataFrame:
    with sync_playwright() as pw:
        for n in range(1, 4):
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            att_dir = RUN_ROOT / ("%s_try%d" % (ts, n))
            att_dir.mkdir(parents=True, exist_ok=True)

            df = do_attempt(pw, att_dir, n)
            if not df.empty:
                klog("Processo concluido na tentativa %d" % n)
                return df

            klog("Tentativa %d falhou, aguardando 5 s\n" % n)
            time.sleep(5)

        kerr("Todas as 3 tentativas falharam")
        return pd.DataFrame()

# ------------------------------------------------------------------
# Execucao para o KNIME
# ------------------------------------------------------------------
output_table = run_pipeline()
