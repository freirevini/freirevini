# -*- coding: utf-8 -*-
"""
MKCompliance – download com 3 tentativas, validacao, compactacao
e uso da pasta Documents\<usuario>\mk

Atualizado: 17-06-2025
"""

import os, sys, time, shutil, zipfile
from datetime import datetime
from pathlib import Path

import pandas as pd
from playwright.sync_api import sync_playwright, expect

# ------------------------------------------------------------------
# Funcoes de log (ASCII / CP-1252 safe)
# ------------------------------------------------------------------
def klog(msg: str):
    sys.stdout.write(msg + "\n")
    sys.stdout.flush()

def kerr(msg: str):
    sys.stderr.write("ERROR: " + msg + "\n")
    sys.stderr.flush()

# ------------------------------------------------------------------
# Pastas dinamicas (Documents\<usuario>\mk)
# ------------------------------------------------------------------
USER_DOCS = Path(os.environ.get("USERPROFILE", str(Path.home()))) / "Documents"
RUN_ROOT  = USER_DOCS / "mk"
RUN_ROOT.mkdir(parents=True, exist_ok=True)

# ------------------------------------------------------------------
# Perfil do Edge usado pela Playwright (mesmo de antes)
# ------------------------------------------------------------------
PROFILE_DIR = Path(
    r"N:/DCGV/Compliance/Compliance RO Varejo/Analytics/Projetos/AgendaNormativa/edge_profile/edge_profile"
).resolve()

# ------------------------------------------------------------------
# URLs da aplicacao
# ------------------------------------------------------------------
LOGIN_INIT_URL = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/"
    "protocol/openid-connect/auth?response_type=code&client_id=alfresco"
    "&redirect_uri=https://bv.mkcompliance.com.br/mk/compliance.html"
)
ADMIN_URL  = "https://bv.mkcompliance.com.br/mk/admin.html#/cfghome"
LOGIN_BASE = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/protocol/openid-connect/auth"
)

TIMEOUT_MS = 90_000
MIN_COLS   = [
    "login", "Nome", "Sobrenome", "E-mail",
    "Telefone", "Departamento", "Área",
]

# ------------------------------------------------------------------
# Uma tentativa individual
# ------------------------------------------------------------------
def do_attempt(play, attempt_dir: Path, attempt_n: int) -> pd.DataFrame:
    """Executa uma tentativa de download. Retorna DataFrame vazio se falhar."""
    file_name = "pontosfocaisMK.xlsx"
    xlsx_path = attempt_dir / file_name
    zip_path  = attempt_dir / (file_name + ".zip")

    ctx = page = None
    df  = pd.DataFrame()

    klog("Attempt %d - dir %s" % (attempt_n, attempt_dir))

    try:
        ctx = play.chromium.launch_persistent_context(
            user_data_dir=PROFILE_DIR,
            channel="msedge",
            headless=False,
            timeout=TIMEOUT_MS,
        )
        page = ctx.new_page()

        # 1) Login (SSO se necessario)
        page.goto(LOGIN_INIT_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        if page.url.startswith(LOGIN_BASE):
            klog("SSO - clicando em Microsoft")
            expect(page.get_by_role("link", name="Microsoft")).to_be_visible(timeout=TIMEOUT_MS)
            page.get_by_role("link", name="Microsoft").click()
            page.wait_for_url("https://bv.mkcompliance.com.br/mk/compliance.html**", timeout=TIMEOUT_MS)

        # 2) Navegacao interna
        page.goto(ADMIN_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        expect(page.get_by_text("Gestão de Usuários Permite")).to_be_visible(timeout=TIMEOUT_MS)
        page.get_by_text("Gestão de Usuários Permite").click()

        # Espera coluna "Área"
        klog("Esperando cabecalho 'Área'")
        expect(page.locator("th", has_text="Área")).to_be_visible(timeout=TIMEOUT_MS)
        page.wait_for_timeout(500)

        # 3) Download
        with page.expect_download(timeout=TIMEOUT_MS) as dl_info:
            page.get_by_role("button", name="Excel").click()
        dl = dl_info.value
        dl.save_as(xlsx_path)
        klog("Salvo em %s" % xlsx_path)

        # espera tamanho estabilizar
        last = -1
        while True:
            size_now = os.path.getsize(xlsx_path)
            if size_now == last:
                break
            last = size_now
            time.sleep(0.4)

        # 4) Ler para DataFrame
        df = pd.read_excel(xlsx_path, header=1, dtype=str)
        klog("Colunas: %s" % list(df.columns))

        # 5) Validacao
        if not all(c in df.columns for c in MIN_COLS):
            kerr("Colunas minimas faltando")
            df = pd.DataFrame()
        else:
            klog("Colunas minimas OK")

        # 6) Compacta e remove xlsx
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
            zf.write(xlsx_path, arcname=file_name)
        os.remove(xlsx_path)
        klog("Compactado em %s.zip e .xlsx removido" % file_name)

    except Exception as e:
        kerr("Falha attempt %d: %s" % (attempt_n, e))
        df = pd.DataFrame()
    finally:
        if ctx:
            ctx.close()

    return df

# ------------------------------------------------------------------
# Pipeline com ate 3 tentativas
# ------------------------------------------------------------------
def run_pipeline() -> pd.DataFrame:
    final_df = pd.DataFrame()

    with sync_playwright() as pw:
        for n in range(1, 4):
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            attempt_dir = RUN_ROOT / ("%s_try%d" % (ts, n))
            attempt_dir.mkdir(parents=True, exist_ok=True)

            df = do_attempt(pw, attempt_dir, n)

            # Remove subpasta criada (zip incluso)
            try:
                shutil.rmtree(attempt_dir, ignore_errors=True)
            except Exception as e:
                kerr("Nao foi possivel remover pasta %s: %s" % (attempt_dir, e))

            if not df.empty:
                klog("Concluido na tentativa %d" % n)
                final_df = df
                break

            klog("Tentativa %d falhou, aguardando 5 s\n" % n)
            time.sleep(5)

    # Se pasta mk ficar vazia, remove
    try:
        if not any(RUN_ROOT.iterdir()):
            RUN_ROOT.rmdir()
    except Exception:
        pass

    if final_df.empty:
        kerr("Todas as 3 tentativas falharam")

    return final_df

# ------------------------------------------------------------------
# Execucao (para KNIME)
# ------------------------------------------------------------------
output_table = run_pipeline()
