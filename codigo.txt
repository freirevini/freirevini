# -*- coding: utf-8 -*-
"""
MKCompliance – Download com 3 tentativas, compactação e validação
17-Jun-2025
"""

import os, sys, time, shutil, zipfile
from datetime import datetime
from pathlib import Path

import pandas as pd
from playwright.sync_api import sync_playwright, expect


# ----------------------------------------------------------------------
# Utilidades de log (compatíveis com nó Python do KNIME)
# ----------------------------------------------------------------------
def klog(msg: str):
    print(msg)
    sys.stdout.flush()


def kerr(msg: str):
    print(f"ERROR: {msg}")
    sys.stderr.flush()


# ----------------------------------------------------------------------
# Pastas e URLs
# ----------------------------------------------------------------------
PROFILE_DIR = Path(
    r"N:/DCGV/Compliance/Compliance RO Varejo/Analytics/Projetos/AgendaNormativa/edge_profile/edge_profile"
).resolve()

ROOT_RUN_DIR = Path(r"C:\Temp\mk_runs").resolve()     # raiz p/ subdiretórios
ROOT_RUN_DIR.mkdir(parents=True, exist_ok=True)

LOGIN_INIT_URL = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/"
    "protocol/openid-connect/auth?response_type=code&client_id=alfresco"
    "&redirect_uri=https://bv.mkcompliance.com.br/mk/compliance.html"
)
ADMIN_URL = "https://bv.mkcompliance.com.br/mk/admin.html#/cfghome"
LOGIN_SERVICE_BASE = (
    "https://bv.mkcompliance.com.br/auth/realms/alfresco/protocol/openid-connect/auth"
)

TIMEOUT_MS = 90_000
REQUIRED = [
    "login", "Nome", "Sobrenome", "E-mail",
    "Telefone", "Departamento", "Área",
]


# ----------------------------------------------------------------------
# Função que faz **uma** tentativa
# ----------------------------------------------------------------------
def do_attempt(play, run_dir: Path, attempt: int) -> pd.DataFrame:
    """
    Faz uma tentativa de baixar e validar a planilha.
    Retorna DataFrame vazio se falhar.
    """
    file_name = f"pontosfocaisMK.xlsx"
    raw_path = run_dir / file_name            # onde o .xlsx é salvo
    zip_path = run_dir / (file_name + ".zip")

    ctx = page = None
    df = pd.DataFrame()

    timestamp_tag = run_dir.name
    klog(f"➜ Tentativa {attempt} – subpasta {timestamp_tag}")

    try:
        ctx = play.chromium.launch_persistent_context(
            user_data_dir=PROFILE_DIR,
            channel="msedge",
            headless=False,
            timeout=TIMEOUT_MS,
        )
        page = ctx.new_page()

        # 1. Login (SSO se necessário)
        page.goto(LOGIN_INIT_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        if page.url.startswith(LOGIN_SERVICE_BASE):
            klog("SSO necessário – clicando em 'Microsoft'…")
            expect(page.get_by_role("link", name="Microsoft")).to_be_visible(timeout=TIMEOUT_MS)
            page.get_by_role("link", name="Microsoft").click()
            page.wait_for_url("https://bv.mkcompliance.com.br/mk/compliance.html**", timeout=TIMEOUT_MS)

        # 2. Vá direto ao admin e abra Gestão de Usuários
        page.goto(ADMIN_URL, wait_until="domcontentloaded", timeout=TIMEOUT_MS)
        expect(page.get_by_text("Gestão de Usuários Permite")).to_be_visible(timeout=TIMEOUT_MS)
        page.get_by_text("Gestão de Usuários Permite").click()

        # 3. Espere a coluna 'Área' aparecer
        klog("Aguardando a grade carregar (coluna 'Área')…")
        expect(page.locator("th", has_text="Área")).to_be_visible(timeout=TIMEOUT_MS)
        page.wait_for_timeout(500)

        # 4. Download
        with page.expect_download(timeout=TIMEOUT_MS) as dl_info:
            page.get_by_role("button", name="Excel").click()
        dl = dl_info.value
        dl.save_as(raw_path)
        klog(f"Arquivo salvo: {raw_path}")

        # espera tamanho estabilizar
        last = -1
        while True:
            size_now = os.path.getsize(raw_path)
            if size_now == last:
                break
            last = size_now
            time.sleep(0.4)

        # 5. Lê para DataFrame
        df = pd.read_excel(raw_path, header=1, dtype=str)
        klog(f"Colunas importadas ({len(df.columns)}): {list(df.columns)}")

        # 6. Validação
        if not all(col in df.columns for col in REQUIRED):
            kerr("↪ Colunas mínimas faltando – tentativa considerada falha.")
            df = pd.DataFrame()
        else:
            klog("✔ Colunas mínimas OK – tentativa considerada SUCESSO.")

        # 7. Compacta antes de copiar
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
            zf.write(raw_path, arcname=file_name)
        os.remove(raw_path)       # remove .xlsx “nu”
        klog(f"Arquivo compactado em {zip_path.name} e original excluído.")

    except Exception as e:
        kerr(f"Falha na tentativa {attempt}: {e}")
        df = pd.DataFrame()
    finally:
        if ctx:
            ctx.close()

    return df


# ----------------------------------------------------------------------
# Função principal – até 3 tentativas
# ----------------------------------------------------------------------
def run_pipeline() -> pd.DataFrame:
    with sync_playwright() as p:
        for attempt in range(1, 4):
            run_dir = ROOT_RUN_DIR / f"{datetime.now():%Y%m%d_%H%M%S}_try{attempt}"
            run_dir.mkdir(parents=True, exist_ok=True)

            df = do_attempt(p, run_dir, attempt)
            if not df.empty:
                klog(f"✓ Processo concluído na tentativa {attempt}.")
                return df

            klog("Aguardando 5 s antes da próxima tentativa…\n")
            time.sleep(5)

        # se chegou aqui, todas falharam
        kerr("✖ Todas as 3 tentativas falharam – devolvendo DataFrame vazio.")
        return pd.DataFrame()


# ----------------------------------------------------------------------
# Execução (KNIME)
# ----------------------------------------------------------------------
output_table = run_pipeline()
